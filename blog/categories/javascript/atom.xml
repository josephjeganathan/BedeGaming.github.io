<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Bede Engineering]]></title>
  <link href="http://engineering.bedegaming.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://engineering.bedegaming.com/"/>
  <updated>2015-06-08T13:37:53+00:00</updated>
  <id>http://engineering.bedegaming.com/</id>
  <author>
    <name><![CDATA[Bede Gaming Ltd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Orchestra - The Journey of a Javascript Framework Part 2]]></title>
    <link href="http://engineering.bedegaming.com/blog/2015/06/04/orchestra-the-journey-of-a-javascript-framework-part2/"/>
    <updated>2015-06-04T14:00:00+00:00</updated>
    <id>http://engineering.bedegaming.com/blog/2015/06/04/orchestra-the-journey-of-a-javascript-framework-part2</id>
    <content type="html"><![CDATA[<p>In part 1 of of this series I wrote about how we refined our build process using Gulp and Browserify, these changes also made a significant impact on the structure of the Orchestra Framework. Part 2 covers how Orchestra transitioned from an all encompassing framework to a library that brings together our favourite tools.</p>

<!-- more -->


<p>The initial vision for Orchestra was to create an application boilerplate that made use of a common toolset we could use for games. Libraries such as <a href="http://marionettejs.com/">MarionetteJS</a>, <a href="http://phaser.io/">Phaser.io</a> and <a href="https://github.com/goldfire/howler.js/">HowlerJS</a> are critical for us to deliver rich gaming content across multiple platforms. The initial application scaffold looked something like this:</p>

<p><img class="center" src="/images/initial-app-structure.png" title="&lsquo;initial application folder structure&rsquo;" ></p>

<p>Drilling further down the tree into the <code>components</code> directory you can see our &lsquo;reuseable&rsquo; components:</p>

<p><img class="center" src="/images/components-directory.png" title="&lsquo;initial components directory&rsquo;" ></p>

<p>The image aboves shows the components for one of our games, these components are meant to be reuseable so how do we include <code>orchestra-chat</code> in another repo? We copy/paste it. This obviously leads to a lot of code duplication across different applications, we had 2 applications running this way before we grew tired of ensuring both versions were up to date. With more applications in the pipeline we decided to restructure our boilerplate.</p>

<h2>Browserify to the rescue</h2>

<p>Browserify makes use of node&rsquo;s CommonJS module loader, to load our component we simply do:</p>

<pre><code>var component = require('app/components/orchestra-chat');
</code></pre>

<p>However, by default the loader will first search the <code>node_modules</code> folder (by default all NPM packages are installed here), with this in mind we converted our components into NPM packages so they could be installed via NPM. Now to load our component we do:</p>

<pre><code>var component = require('orchestra-chat');
</code></pre>

<p>Utilising the NPM package manager has enabled us to remove components from the applications and include them in the application&rsquo;s dependencies so they are installed at build time. This brings our folder structure to what we have today:</p>

<p><img class="center" src="/images/new-folder-structure.png" title="&lsquo;new application folder structure&rsquo;" ></p>

<p>In addition to the streamlined folder structure we are now able to avoid duplicating code across multiple repositories, utilising the power of the NPM package manager. You may also have noticed in the image above we have removed <code>helpers</code>, <code>mixins</code> and <code>models</code>. These directories also contained common code shared between applications, for example a translation helper, a currency display helper or a mixin for touch events. This was code that didn&rsquo;t belong in any particular component but was more part of the framework itself, what we did next was create an Orchestra library which became a dependency of the applications.</p>

<h2>Orchestra the library</h2>

<p>We needed to remove this common code from applications, the next logical step was to convert Orchestra itself into a library. It has proven to be an inspired decision. Orchestra is now a library with it&rsquo;s own opinions about what tools to use for certain jobs, it extends Marionette and <a href="https://github.com/marionettejs/backbone.radio">Backbone.Radio</a>, provides access to utility libraries such as <a href="https://lodash.com/">lodash</a> and helpers for things such as translation, currency and local storage.</p>

<p>This reduces code duplication and simplifes our modules, rather than pulling in each dependency individually we simply include Orchestra and know that it has all the tools we need.</p>

<h2>The Future&hellip;</h2>

<p>My aim for Orchestra would be to release it to the community and Open Source the library, there is still some work to do - but it&rsquo;s not far off. Our Yeoman generator is quite out of date and needs updating for our new application structure, PR&rsquo;s welcome <a href="https://github.com/BedeGaming/protege">here</a>. Now that Orchestra is a library rather than a framework, we aren&rsquo;t necessarily limited to game applications.</p>

<p><strong>Orchestra: Client-side <del>Game</del> CMS Widget Orchestration <del>Framework</del> Library</strong></p>

<p>Coming next in this series I&rsquo;ll talk about how our applications hook together, an app having lots of separate components needs a good method of communcation. Ill go in depth with our event architecture and explain why <a href="https://facebook.github.io/flux/">Facebook&rsquo;s Flux Architecture</a> maybe isn&rsquo;t quite as innovative as many think&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Orchestra - The Journey of a Javascript Framework Part 1]]></title>
    <link href="http://engineering.bedegaming.com/blog/2015/04/16/orchestra-the-journey-of-a-javascript-framework/"/>
    <updated>2015-04-16T14:00:00+00:00</updated>
    <id>http://engineering.bedegaming.com/blog/2015/04/16/orchestra-the-journey-of-a-javascript-framework</id>
    <content type="html"><![CDATA[<p>Recently I&rsquo;ve been excitedly talking to my colleagues about Orchestra, a &ldquo;Super awesome framework&rdquo; we have built in the Bede Games Studio, so I thought I&rsquo;d give them all a break a write a blog post about it instead!</p>

<!-- more -->


<h2>What is Orchestra?</h2>

<p>The chances are, you&rsquo;re probably reading this wondering what on Earth Orchestra actually is. In a nutshell, it&rsquo;s a purpose built Javascript framework for large scale applications. Harnessing the flexibility of <a href="http://marionettejs.com/">MarionetteJS</a> framework, it gives us the tools we need to enable us to implement some battle tested patterns for large scale Javascript applications.</p>

<p>It was built with the modularity and flexibility of the Bede platform in mind. Apps are split into smaller reusable  components: Chat, Tickets, Countdown etc for the Bingo Client, what this means is, should we decide we want a chat client in another game, we just include the orchestra-chat component and provide its config and &lsquo;it will just work&rsquo;. It has built in support for theming and localisation, allowing us to easily skin up new designs based on existing components. Our Bingo client is a great example of this in action. All of the bingo clients use the same core codebase, with a different theme and language file.</p>

<p>Even in its early days it was clear Orchestra was going to be a great fit for Bingo but now we have taken this a step further with a series of changes, and built our Slots Client using the same framework. The aim of this post is to explain the changes we made and the rationale behind them.</p>

<h2>The battle of the Javascript Build Tools</h2>

<p>If I had a Â£ for every article I&rsquo;ve read with this heading as the title I&rsquo;d be an extremely rich man and would probably be writing this post from my yacht in the Bahamas. So, originally <a href="http://gruntjs.com">Grunt</a> was the build tool used for all our JS projects at Bede, it was amazing - everyone loved it, but, then something changed&hellip; <a href="http://gulpjs.com">Gulp</a> came along.</p>

<p>Now before you all think this is another case of simply jumping on a bandwagon, let me provide some justification for converting our build from Grunt to Gulp. We know that Gulp provides two main benefits:</p>

<ol>
<li>Code over configuration</li>
<li>Speed</li>
</ol>


<p>But what difference do these make to our apps? Code over configuration is something that is quite a difficult sell, however take a look at this snippet from our old Gruntfile:</p>

<pre><code class="js">less: {
    development: {
        options: {
            sourceMap: true,
            ieCompat: true,
            customFunctions: {
                'assets-path': function (less, path) {
                    return '/assets/media/' + path.value;
                }
            }
        },
        files: {
            'assets/css/bingostars/desktop.css': ['assets/less/themes/bingostars/desktop/main.less'],
            'assets/css/bingostars/mobile.css': ['assets/less/themes/bingostars/mobile/main.less'],
            'assets/css/healthbingo/desktop.css': ['assets/less/themes/healthbingo/desktop/main.less'],
            'assets/css/healthbingo/mobile.css': ['assets/less/themes/healthbingo/mobile/main.less'],
            'assets/css/stv/desktop.css': ['assets/less/themes/stv/desktop/main.less'],
            'assets/css/stv/mobile.css': ['assets/less/themes/stv/mobile/main.less'],
            'assets/css/betvictor/desktop.css': ['assets/less/themes/betvictor/desktop/main.less'],
            'assets/css/betvictor/mobile.css': ['assets/less/themes/betvictor/mobile/main.less'],
            'assets/css/lovebingo/desktop.css': ['assets/less/themes/lovebingo/desktop/main.less'],
            'assets/css/lovebingo/mobile.css': ['assets/less/themes/lovebingo/mobile/main.less']
        }
    }
}
</code></pre>

<p>and compare it to:</p>

<pre><code class="js">var lessTaskNames = ['cleanCSS'].concat(themeTaskGenerator('less', function (theme, platform) {
  return gulp.src('assets/less/themes/' + theme.name + '/' + platform + '/main.less')
    .pipe(less({
      modifyVars: {
        'asset-path': '"/assets"'
      }
    }))
    .pipe(rename(platform + '.css'))
    .pipe(gulp.dest('assets/css/' + theme.name + '/'));
}));
</code></pre>

<p>From our new Gulp task, straight away you can see the reduced lines of code, but perhaps hidden in here is what I would consider a bigger benefit. Notice the list of output files in the Grunt config? This grows with every new theme, but because Gulp is code based, we can simply iterate over a <code>themes</code> array.</p>

<p>Something that is not such a difficult sell is the time shaved off our build task. Before Gulp we built 6 themes in a total time of 8 minutes, now, after the conversion, we are building 12 themes in 6 minutes - I think we can class that as a win. There are 2 main reasons for this speed benefit:
* Tasks are ran concurrently by default, whereas Grunt will only run tasks asynchronously.
* Gulp makes use of <code>pipe</code> which is native in node and most popular OS&rsquo;s. This means that whereas Grunt is required to create temporary files for its tasks, Gulp can pipe a file into its next task.</p>

<h2>The battle of the Javascript Module Loaders</h2>

<p>I&rsquo;m guessing you can see a theme appearing here, yet another well trodden path in the plethora of JavaScript blogs/articles is the comparison of the different module loaders available.
For me there are 3 main contenders:
* <a href="http://requirejs.org">RequireJS</a> which will load in AMD modules
* <a href="http://browserify.org">Browserify</a> which will load in CommonJS modules and
* <a href="http://webpack.github.io">Webpack</a> which will load anything and everything.</p>

<p>It should be noted that ES6 brings a new module pattern, which the community hopes will bring some unity. It is possible to start using these new ES6 features now with the help of <a href="http://babeljs.io/">Babel</a> which, will transpile ES6 modules to either AMD or CommonJS until they are widely available. I&rsquo;ve dabbled with Babel a bit and have some friends that work on the Babel project, it looks amazing, but we&rsquo;re not switching just yet! :smile:</p>

<p>Originally Orchestra was setup to build using AMD modules with the RequireJS tool, this was something that hindered us for a couple of reasons:</p>

<ul>
<li>The modules are loaded at the same time during development vs concatenated during a production build.</li>
<li>The build time was around 60 seconds per theme using RequireJS.</li>
</ul>


<p>Gulp is also unable to run these tasks concurrently, as that isn&rsquo;t supported by the RequireJS compiler. We needed to look at the alternatives. Browserify came up trumps - it allowed us to use the same module pattern across browser apps and Node.js apps and also solved the 2 problems I mentioned above: Your development version is the same as the production build, it compiles and provides sourcemaps (the overhead for the compile step when using <a href="https://github.com/substack/watchify">watchify</a> is milliseconds) and the build time per theme was reduced to 18 seconds - when you add the benefit of building all themes concurrently, its easy to see why this was a wise move for us!</p>

<p>That&rsquo;s it for part 1, in part 2 I&rsquo;ll cover changes that were made as more apps began to use the Orchestra framework.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How the current mobile landscape affects developers]]></title>
    <link href="http://engineering.bedegaming.com/blog/2014/10/20/developers-and-the-changing-mobile-landscape/"/>
    <updated>2014-10-20T15:55:00+00:00</updated>
    <id>http://engineering.bedegaming.com/blog/2014/10/20/developers-and-the-changing-mobile-landscape</id>
    <content type="html"><![CDATA[<p>A colleague pointed me towards an interesting <a href="http://www.slideshare.net/robnyman/mobile-trends-web-native">presentation</a> that illustrates some dramatic shifts in the mobile market. I think it&rsquo;s important that mobile app developers take a close look at how this may impact apps they are working on. Here we discuss issues and possible solutions to the problems that may arise.</p>

<!-- more -->


<h2>The mobile OS battle</h2>

<p>Whether this can be classed as a battle anymore is up for debate but currently Android leads the way and now owns approximately 85% of the market, compare that to 2012 when it was hitting 69% and in 2011 it was only 36%! Looking across at iOS which has dropped from 18% to 11% in the same time period it is certainly looking like the two big players are still the main targets for users, Blackberry has virtually disappeared and Windows Phone seems more appealing to developers than consumers.</p>

<p>Another interesting point is the disappearance of the &ldquo;Other&rdquo; OS&rsquo;s. In 2011 this figure occupied 30% of the market, it now comprises a tiny 0.7%. My opinion here is that this is mainly to do with some of the big mobile handset manufactors moving away from Symbian as their primary platform. Samsung and Sony Ericsson have of course moved to Android whereas Nokia have adopted the Windows Phone OS. So what does this mean for developers?</p>

<p><img class="center" src="/images/smartphone-os-market-share.png" title="&lsquo;Smartphone OS Market Share&rsquo; &lsquo;Smartphone OS Market Share&rsquo;" ></p>

<p><em>Source: <a href="http://www.idc.com/prodserv/smartphone-os-market-share.jsp">idc.com</a></em></p>

<h3>Android fragmentation</h3>

<p>Firstly, the fragmentation of the Android market means there are many devices to support whereas on iOS there are a known set of devices to target. This leads to problems with differing device performance levels, screen resolutions and OS versions. For mobile web apps or sites you can add the usual cross browsers incompatibilities to that list.</p>

<h3>High end devices</h3>

<p>Despite Android&rsquo;s 85% market share dwarfing iOS&rsquo;s 11%, you may be surprised to hear that iOS still holds the greater market share when it comes to the high end devices. This is a key consideration to take into account when you analyse the target audience for your app or wesbite.</p>

<h3>App distribution</h3>

<p>Each OS comes with its own app distribution channel, on iOS we have the App Store and Android the Play Store (we should also try not to forget about the Windows Store). The different stores have their own restrictions on the types of app they host, the Play Store for example does not allow gambling apps and also a varying review process. The native language used to develop apps for each OS also varies:</p>

<ul>
<li>Android - Java</li>
<li>iOS - Objective-C / Swift</li>
<li>Windows - C++ / .NET</li>
</ul>


<p>This sets an obvious challenge to developers looking to publish on each store, is it really worth writing an app 3 times?</p>

<h2>So what can we do about it?</h2>

<p>Ok, I&rsquo;ve listed some of the issues that can arise when thinking about developing your latest app or website now how do we solve these isssues? Lets take a look at dealing with the many different devices on the market today. For me, the key here is to know your target audience and plenty of research. Its also useful to consider what your app or site is going to do, ask yourself these questions:</p>

<ol>
<li>What does my app do?</li>
<li>Will it need good hardware?</li>
<li>Am I willing compromise app experience?</li>
</ol>


<p>Three questions that sound obvious but once answered, can really help narrow down that extensive device list - if your app doesnt include rich graphics or intensive animations then its probably safe to widen the range of handsets you are going to target or if it&rsquo;s a game for example then you probably want to stick with the higher end of the market. Likewise if your app is heavily reliant on rich animations and graphics and a reduced experience is not really an option then again this will limit you to the high end devices.</p>

<h3>Development approach</h3>

<p>So we&rsquo;ve limited our device range but we still have a problem in that we need to build the same app 3 times in a different language to reach the maximum number of people. Or do we? No of course not - there are lots of tools available now that allow developers to write once, run anywhere (and no I dont mean Java!). In fact the aforementioned document talks about how almost half of mobile app developers choose to write apps using something other than the native language.</p>

<h4>Unity3D</h4>

<p>Unity is a hugely popular game development tool, it allows its users to create games for a wide variety of platforms. Its performance is a near match for its native equivilents and the quality of games rendering is second to none.</p>

<p>Skills for Unity tend be more difficult to find when compared to native iOS/Android and HTML5, probably because its popularity mainly stems from the games industry, however there is a large community behind it and a new Unity Store where developers can download assets and plugins for their games.</p>

<p>In my opinion, aside from the skill shortage, where Unity falls down is when it comes to app distruption. As with most channels you still have the review process for the various app stores and each new version must go through a similar review.</p>

<h4>Haxe</h4>

<p>Haxe is a relatively new tool that has been brought to my attention recently, it is source to source complier or <em>transpiler</em> for a more appropriate term. This gives developers the ability to write their app once in the Haxe language and &lsquo;transpile&rsquo; into a variety of native languages, current language support includes:</p>

<ul>
<li>iOS</li>
<li>Android</li>
<li>HTML5</li>
<li>Flash</li>
<li>C#</li>
<li>PHP</li>
<li>C++ and more</li>
</ul>


<p>The toolkit has gained backing from some well known companies like Tivo, Prezi and Zynga to name a few and also has a growing open source community which should mean further advances in the native API&rsquo;s. Where this struggles in my opinion is there will always be issues for transpiled languages where some areas of the API dont work cross platform so you maybe forced to restrict functionality in your app to cater for this. That said I imagine the API&rsquo;s available will cater for the majority of apps.</p>

<p>I&rsquo;m not usually a fan of transpilers, I&rsquo;ll stop now before I start a rant about CoffeeScript (one for another post!), but this one certainly looks to have its place in the market and I will be looking into this more in the near future.</p>

<h4>HTML5 and beyond!</h4>

<p>At Bede we are big adovcates of HTML5 and its surrounding technologies. Our games clients make use of the latest HTML5 API&rsquo;s, Javascript frameworks and CSS3 and our CMS uses a variant of responsive design to cater for varying screen resolutions and devices.</p>

<p>All the major mobile platforms support apps built in HTML5. Whether its an app to be published on the app store built with something like <a href="http://cordova.apache.org/">Apache Cordova</a> or one of its distributions, <a href="http://phonegap.com/">PhoneGap</a> is one of the more popular names or a web app saved from the web - Google and Apple are definitely getting behind the HTML5 revolution! An article over at <a href="http://www.sencha.com/blog/apple-shows-love-for-html5-with-ios-8">Sencha</a> details how iOS 8 adds support for many more HTML5 features, couple this with the recent addition of the &lsquo;Nitro&rsquo; Javascript engine to UIWebView and you can see how Apple are embracing HTML5.</p>

<p><img class="center" src="/images/ios-html5-support.png" title="&lsquo;iOS HTML5 feature support comparison&rsquo; &lsquo;iOS HTML5 feature support comparison&rsquo;" ></p>

<p><em>Source: <a href="http://caniuse.com">caniuse.com</a></em></p>

<p>Google continue to improve the Android experience by making Chrome the default browser in the latest versions of Android, finally ridding HTML5 developers of the native Android browser (or &lsquo;the IE6 of mobile&rsquo; as I like to call it). Performance used to be the main drawback of this approach but the latest developments with full webGL support meaning  hardware accerlation for HTML5 canvas and more powerful devices hitting the market, this is less of a concern these days.</p>

<p>In my opinion HTML5 is succeeding in becoming <em>the</em> write once, run everywhere choice for mobile app development. Maybe only the ultra high performance games have the performance concern now - for the vast majority of developers we can safely rely on HTML5 to deliver what we need in terms of app development. If done correctly the performance difference should be barely noticeable.</p>

<p>An added bonus is that creating a hybrid app with HTML5 means you can auto update you app without needing to go through a review in the app stores for the new content, deploying the latest version to the web will in turn update the app content. This may seem like a small advantage at first but for an app that may require frequent improvements and many iterations it is an invaluable feature.</p>

<p>As described above HTML5 plays a big part in the products delivered by Bede and based on some figures I was shown recently that indicated 40% of traffic on a popular client site came from mobile devices, I believe we are a good case study on the benefits the technology can bring. Aside from the aesthetics of sites and the rich interfaces we can create using the stack, topics like team structure and recruitment strategy are also key bonus points. Across the different teams in Bede a lot of shared code can be utilised - a repository of less mixins is available to developers and our games clients are written using our Javascript framework. Traditionally HTML5 skills have been easier to recruit for than traditional tech skills associated with mobile development, this has allowed Bede to quickly grow a highly talented team.</p>

<p>The main advantage HTML5 gives Bede over its competitors is the ability to rapidly produce rich applications that are highly configurable to the point where it is difficult to identify the software running underneath, compare 2 of our Bingo clients with 2 from a competitor and you will see what I mean!</p>
]]></content>
  </entry>
  
</feed>
